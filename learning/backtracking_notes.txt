## Learning: Backtracking

In my ongoing effort to strengthen my problem-solving skills, I have been studying backtracking algorithms. This section documents what I have learned, the practice problems I implemented, and my reflections on the challenges and optimizations encountered along the way.

### Overview

Recently, I’ve been studying **backtracking algorithms**, focusing on how they apply to constraint satisfaction problems like Sudoku, the N-Queens problem, and the Knight’s Tour.  
Backtracking is a problem-solving technique that systematically explores all possible solutions by building candidates incrementally and abandoning paths that violate constraints. Recursive solutions often naturally lend themselves to backtracking, although the backtracking process can sometimes be hidden within the recursion.

Key resources I used during this study:
- [Backtracking (Think Like a Programmer)](https://www.youtube.com/watch?v=gBC_Fd8EE8A)
- [Intro to Backtracking (GeeksforGeeks)](https://www.geeksforgeeks.org/introduction-to-backtracking-2/)
- [Backtracking Coding Template (YouTube)](https://www.youtube.com/watch?v=vqnZ9RhhkmY)
- [Recursion and Backtracking (HackerEarth)](https://www.hackerearth.com/practice/basic-programming/recursion/recursion-and-backtracking/tutorial/)

---

### Concepts and Techniques

**Backtracking Terminology:**
- **Candidate:** A potential choice that could be part of a solution.
- **Solution:** A complete, valid configuration.
- **Partial Solution:** An incomplete configuration being built.
- **Decision Space:** All available choices at a decision point.
- **Dead End:** A path that cannot proceed without violating constraints.
- **Backtrack:** Undoing a previous decision to explore a different path.
- **Search Space:** All possible configurations.
- **Optimal Solution:** The best possible valid solution according to given criteria.

**Types of Backtracking Problems:**
- **Decision Problems:** Find any feasible solution.
- **Optimization Problems:** Find the best solution.
- **Enumeration Problems:** Find all possible solutions.

**Key distinction:**  
While recursion breaks problems into smaller subproblems, backtracking specifically explores multiple choices and undoes decisions when necessary. Backtracking is generally managed explicitly with loops and state tracking, rather than purely through the call stack.

---

### Common Backtracking Structure

```pseudo
backtrack(candidates, target, currentPath):
    if currentPath meets target condition:
        record solution
        return

    for each candidate in candidates:
        if candidate is valid:
            add candidate to currentPath
            backtrack(candidates, target, currentPath)
            remove candidate from currentPath
```

---

### Practice Problems

To reinforce my understanding, I implemented backtracking solutions for several classic problems:

**N-Queens Problem**
- Place N queens on an N×N chessboard such that no two queens threaten each other.
- Focus: Constraint satisfaction and placement validity.

**Rat in a Maze**
- Find a path from the top-left to the bottom-right of a grid by moving only right or down through open cells.
- Focus: Pathfinding with constrained movement options.

**Knight’s Tour**
- Move a knight across an N×N chessboard, visiting each square exactly once.
- Focus: Deep search and move sequencing.

---

### Reflection and Next Steps

While my solutions performed well for smaller problem sizes, I encountered performance issues with larger Knight’s Tour boards (N = 6, 7, 8). The brute-force backtracking approach led to extremely long runtimes, exploring millions or billions of paths without optimization.

To improve, I am now studying **Warnsdorff’s Rule** — a heuristic that prioritizes moves with the fewest onward moves, greatly reducing the search space. Implementing this optimization should make my Knight’s Tour solution far more efficient and allow it to handle larger board sizes.
